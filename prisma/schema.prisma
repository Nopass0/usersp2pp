generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  USERCARDS
}

model User {
  id                  Int                  @id @default(autoincrement())
  name                String
  passCode            String               @unique
  isActive            Boolean              @default(true)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  lastNotification    DateTime?
  role                UserRole             @default(USER)
  bybitTransactions   BybitTransaction[]
  reportNotifications ReportNotification[]
  telegramAccounts    TelegramAccount[]
  transactions        Transaction[]
  workSessions        WorkSession[]

  auditLogs AuditLog[] // Relation to audit logs initiated by this user
}

model TelegramAccount {
  id         Int      @id @default(autoincrement())
  telegramId String   @unique
  username   String?
  firstName  String?
  lastName   String?
  userId     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Admin {
  id         Int      @id @default(autoincrement())
  telegramId String   @unique
  username   String?
  firstName  String?
  lastName   String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model SystemSettings {
  id                     Int      @id @default(autoincrement())
  reportReminderInterval Int      @default(180)
  reportWaitTime         Int      @default(10)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

model Transaction {
  id           Int      @id @default(autoincrement())
  externalId   String?
  orderNo      String?
  dateTime     DateTime
  type         String
  asset        String
  amount       Float
  totalPrice   Float
  unitPrice    Float
  counterparty String?
  status       String
  originalData Json?
  userId       Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  matches      Match[]
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([externalId, userId])
}

model BybitTransaction {
  id           Int          @id @default(autoincrement())
  orderNo      String
  counterparty String?
  status       String
  userId       Int
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  amount       Float
  asset        String
  dateTime     DateTime
  originalData Json?
  totalPrice   Float
  type         String
  unitPrice    Float
  BybitMatch   BybitMatch[]
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orderNo, userId])
}

model WorkSession {
  id            Int           @id @default(autoincrement())
  startTime     DateTime
  endTime       DateTime?
  duration      Int?
  autoCompleted Boolean       @default(false)
  userId        Int
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  comment       String?
  idexCabinets  IdexCabinet[]
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ReportNotification {
  id               Int       @id @default(autoincrement())
  notificationTime DateTime
  reportReceived   Boolean   @default(false)
  reportTime       DateTime?
  adminNotified    Boolean   @default(false)
  adminNotifyTime  DateTime?
  userId           Int
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model NotificationSettings {
  id        Int      @id @default(autoincrement())
  settings  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model IdexCabinet {
  id            Int               @id @default(autoincrement())
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  idexId        Int
  login         String
  password      String
  workSessionId Int?
  WorkSession   WorkSession?      @relation(fields: [workSessionId], references: [id])
  IdexSyncOrder IdexSyncOrder[]
  transactions  IdexTransaction[]
}

model IdexTransaction {
  id                Int          @id @default(autoincrement())
  externalId        BigInt
  paymentMethodId   BigInt
  wallet            String
  amount            Json
  total             Json
  status            Int
  approvedAt        String?
  expiredAt         String?
  createdAtExternal String
  updatedAtExternal String
  extraData         Json
  cabinetId         Int
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  BybitMatch        BybitMatch[]
  cabinet           IdexCabinet  @relation(fields: [cabinetId], references: [id], onDelete: Cascade)
  matches           Match[]

  @@unique([externalId, cabinetId])
}

model Match {
  id                Int             @id @default(autoincrement())
  idexTransactionId Int
  transactionId     Int
  timeDifference    Int
  grossExpense      Float
  grossIncome       Float
  grossProfit       Float
  profitPercentage  Float
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  idexTransaction   IdexTransaction @relation(fields: [idexTransactionId], references: [id])
  transaction       Transaction     @relation(fields: [transactionId], references: [id])

  @@unique([idexTransactionId, transactionId])
}

model BybitMatch {
  id                 Int              @id @default(autoincrement())
  idexTransactionId  Int
  bybitTransactionId Int
  timeDifference     Int
  grossExpense       Float
  grossIncome        Float
  grossProfit        Float
  profitPercentage   Float
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  bybitTransaction   BybitTransaction @relation(fields: [bybitTransactionId], references: [id])
  idexTransaction    IdexTransaction  @relation(fields: [idexTransactionId], references: [id])

  @@unique([idexTransactionId, bybitTransactionId])
}

model Card {
  id          Int           @id @default(autoincrement())
  externalId  Int
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  provider    String
  cardNumber  String
  bank        String
  phoneNumber String
  appPin      Int
  terminalPin String
  comment     String?
  picachu     String?
  status      CardStatus    @default(ACTIVE)
  cardPrice   Float?
  isPaid      Boolean       @default(false)
  balances    CardBalance[]
  cardPouring CardPouring[]

  auditLogs AuditLog[] @relation("CardAuditLogs") // Specific relation for Card logs
}

// --- Audit Log Model ---
enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

model AuditLog {
  id         Int         @id @default(autoincrement())
  entityType String // e.g., "Card", "CardBalance", "CardPouring"
  entityId   Int // ID of the record in its respective table
  action     AuditAction
  userId     Int
  user       User        @relation(fields: [userId], references: [id])
  timestamp  DateTime    @default(now())
  oldValue   Json? // State before change (null for CREATE)
  newValue   Json? // State after change (null for DELETE)

  // Optional specific relations with explicit mapping
  card        Card?        @relation("CardAuditLogs", fields: [entityId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "auditlog_card_fk") // Added map
  cardBalance CardBalance? @relation("CardBalanceAuditLogs", fields: [entityId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "auditlog_cardbalance_fk") // Added map
  cardPouring CardPouring? @relation("CardPouringAuditLogs", fields: [entityId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "auditlog_cardpouring_fk") // Added map

  @@index([entityType, entityId]) // Index for faster lookup of logs for a specific entity
  @@index([userId]) // Index for user's actions
}

model CardBalance {
  id           Int      @id @default(autoincrement())
  cardId       Int
  date         DateTime
  startBalance Float
  endBalance   Float
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  card         Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)

  auditLogs AuditLog[] @relation("CardBalanceAuditLogs") // Specific relation for Balance logs

  @@unique([cardId, date])
}

model Salary {
  id          Int             @id @default(autoincrement())
  fullName    String
  position    String
  startDate   DateTime
  payday      Int
  paydayMonth Int?
  fixedSalary Float?
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  FinRow      FinRow[]
  SalaryDebt  SalaryDebt[]
  payments    SalaryPayment[]
  ShiftReport ShiftReport[]
}

model SalaryPayment {
  id          Int      @id @default(autoincrement())
  salaryId    Int
  amount      Float
  paymentDate DateTime
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  currency    String   @default("RUB")
  salary      Salary   @relation(fields: [salaryId], references: [id])
}

model IdexSyncOrder {
  id          Int                 @id @default(autoincrement())
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  cabinetId   Int?
  processed   Json?
  status      IdexSyncOrderStatus
  startSyncAt DateTime?
  endSyncAt   DateTime?
  pages       Int[]
  cabinet     IdexCabinet?        @relation(fields: [cabinetId], references: [id], onDelete: Cascade)
}

model CardPouring {
  id               Int        @id @default(autoincrement())
  cardId           Int
  pouringDate      DateTime
  initialAmount    Float
  initialDate      DateTime
  finalAmount      Float?
  finalDate        DateTime?
  pouringAmount    Float
  withdrawalAmount Float?
  withdrawalDate   DateTime?
  collectorName    String?
  status           CardStatus @default(ACTIVE)
  comment          String?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt // Should be @updatedAt
  card             Card       @relation(fields: [cardId], references: [id], onDelete: Cascade) 

  auditLogs AuditLog[] @relation("CardPouringAuditLogs") // Specific relation for Pouring logs
}

model Cell {
  id              Int       @id @default(autoincrement())
  rowId           Int
  columnId        Int
  value           String?
  displayValue    String?
  calculatedValue String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime
  Column          Column    @relation(fields: [columnId], references: [id], onDelete: Cascade)
  Row             Row       @relation(fields: [rowId], references: [id], onDelete: Cascade)
  Comment         Comment[]

  @@unique([rowId, columnId])
}

model Column {
  id           Int        @id @default(autoincrement())
  name         String
  type         ColumnType
  tableId      Int
  width        Int?
  isRequired   Boolean    @default(false)
  isFilterable Boolean    @default(false)
  isSummable   Boolean    @default(false)
  defaultValue String?
  format       String?
  order        Int
  options      Json?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime
  Cell         Cell[]
  Table        Table      @relation(fields: [tableId], references: [id], onDelete: Cascade)
  Filter       Filter[]
}

model Comment {
  id        Int      @id @default(autoincrement())
  cellId    Int
  text      String
  author    String?
  createdAt DateTime @default(now())
  updatedAt DateTime
  Cell      Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
}

model Filter {
  id          Int            @id @default(autoincrement())
  name        String
  tableId     Int
  columnId    Int
  operator    FilterOperator
  value       String?
  secondValue String?
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime
  Column      Column         @relation(fields: [columnId], references: [id], onDelete: Cascade)
  Table       Table          @relation(fields: [tableId], references: [id], onDelete: Cascade)
}

model FinRow {
  id            Int             @id @default(autoincrement())
  date          DateTime
  time          String
  shift         String
  startBalance  Float
  endBalance    Float
  employeeId    Int?
  usdtAmount    Float           @default(0)
  comment       String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime
  currency      String          @default("RUB")
  Salary        Salary?         @relation(fields: [employeeId], references: [id])
  FinRowExpense FinRowExpense[]
}

model FinRowExpense {
  id          Int      @id @default(autoincrement())
  finRowId    Int?
  expenseType String
  amount      Float
  date        DateTime
  time        String
  period      String?
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  currency    String   @default("RUB")
  FinRow      FinRow?  @relation(fields: [finRowId], references: [id])
}

model ImportExport {
  id        Int      @id @default(autoincrement())
  tableId   Int
  name      String
  type      String
  mappings  Json
  options   Json?
  createdAt DateTime @default(now())
  updatedAt DateTime
}

model Row {
  id        Int      @id @default(autoincrement())
  tableId   Int
  order     Int
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime
  Cell      Cell[]
  Table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
}

model SalaryDebt {
  id          Int      @id @default(autoincrement())
  salaryId    Int
  amount      Float
  debtDate    DateTime
  description String?
  isPaid      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  Salary      Salary   @relation(fields: [salaryId], references: [id], onDelete: Cascade)
}

model Section {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  slug        String   @unique
  isActive    Boolean  @default(true)
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  Table       Table[]
}

model ShiftReport {
  id                 Int                  @id @default(autoincrement())
  date               DateTime
  time               String
  shift              String
  startBalance       Float
  endBalance         Float
  employeeId         Int?
  usdtAmount         Float                @default(0)
  currency           String               @default("RUB")
  comment            String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime
  Salary             Salary?              @relation(fields: [employeeId], references: [id])
  ShiftReportExpense ShiftReportExpense[]
}

model ShiftReportExpense {
  id            Int          @id @default(autoincrement())
  shiftReportId Int?
  expenseType   String
  amount        Float
  currency      String       @default("RUB")
  date          DateTime
  time          String
  period        String?
  description   String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime
  ShiftReport   ShiftReport? @relation(fields: [shiftReportId], references: [id])
}

model Table {
  id            Int      @id @default(autoincrement())
  name          String
  description   String?
  sectionId     Int
  isSearchable  Boolean  @default(true)
  hasPagination Boolean  @default(true)
  pageSize      Int      @default(10)
  order         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime
  Column        Column[]
  Filter        Filter[]
  Row           Row[]
  Section       Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)
}

enum IdexSyncOrderStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum CardStatus {
  ACTIVE
  WARNING
  BLOCKED
}

enum ColumnType {
  TEXT
  NUMBER
  DATE
  DATETIME
  BOOLEAN
  SELECT
  BUTTON
  CALCULATED
  CURRENCY
  LINK
  COMMENT
}

enum FilterOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  GREATER_OR_EQUAL
  LESS_OR_EQUAL
  CONTAINS
  NOT_CONTAINS
  STARTS_WITH
  ENDS_WITH
  BETWEEN
  IN_LIST
}
